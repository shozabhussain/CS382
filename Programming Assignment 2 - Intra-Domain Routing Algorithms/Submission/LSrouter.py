import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph, find_path


class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0

        # Hints: initialize local state

        self.graph = Graph(undirected=True)                 # a graph to store a global view of network
        self.my_link_state = {}                             # a dictionary to store the node's link state
        self.forwarding_table = {}                          # a dictionary to store forwarding table
        self.last_seqno = 0                                 # a counter to keep track of node's own link state version
        self.other_link_states = {}                         # a dictionary to store link states of other nodes
        self.graph.add_edge(self.addr, self.addr, 0)        # initialise the graph by adding itself in it
        self.replica = {}                                   # a dictionary to store the neighbours and their respective ports
        self.seqnos = {}                                    # a dictionary to store the versions of link states of other nodes


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""

        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)

            # checks if the dest.node is in the forwading table
            if packet.dstAddr in self.forwarding_table.keys():

                # checks if the we have a link to from nbr to dest.node
                if (self.forwarding_table[packet.dstAddr]) in self.replica.keys():

                    # extract to nbr node then extract it's port and then send
                    self.send(self.replica[(self.forwarding_table[packet.dstAddr])], packet)

        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors

            recv_link_state, seqno_recv = loads(packet.content)

            # if the node is new, add it's link state and it's version
            if packet.srcAddr not in self.seqnos.keys():
                self.seqnos[packet.srcAddr] = seqno_recv
                self.other_link_states[packet.srcAddr] = recv_link_state
                self.update_graph()
                self.update_forwading_table()
                self.broadcast_handle_packet(packet.srcAddr, packet)

            # if the version is new then update the version
            elif seqno_recv > self.seqnos[packet.srcAddr]:

                self.seqnos[packet.srcAddr] = seqno_recv

                # update the copy of link state of node that has changed
                self.other_link_states[packet.srcAddr] = recv_link_state
                self.update_graph()
                self.update_forwading_table()

                # broadcast the recved link state to nbrs
                self.broadcast_handle_packet(packet.srcAddr, packet)


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors

        # add the new link as nbr
        self.my_link_state[endpoint] = (port, cost)
        self.update_graph()
        self.last_seqno = self.last_seqno + 1
        self.update_forwading_table()
        packet_to_send = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr= self.addr, content= dumps([self.my_link_state, self.last_seqno]))

        # broadcasts new link state to nbrs
        self.broadcast(packet_to_send)
        self.replica[endpoint] = port


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors

        endpoint_remove = list(self.replica.keys())[list(self.replica.values()).index(port)]

        # remove the node as nbr
        del self.my_link_state[endpoint_remove]
        del self.replica[endpoint_remove]
        self.update_graph()
        self.last_seqno = self.last_seqno + 1
        self.update_forwading_table()
        packet_to_send = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr= self.addr, content= dumps([self.my_link_state, self.last_seqno]))

        # broadcasts new link state to nbrs
        self.broadcast(packet_to_send)


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors

            packet_to_send = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr= self.addr, content= dumps([self.my_link_state, self.last_seqno]))
            self.broadcast(packet_to_send)


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return dumps(self.forwarding_table)


    def broadcast(self, packet):

        for x in self.my_link_state.keys():

            # sends packet to all the nbrs in the link state
            self.send(self.my_link_state[x][0], packet)


    def update_forwading_table(self):

        # updates forwarding table first from own link state and then from other nodes
        for x in self.my_link_state.keys():

            self.forwarding_table[x] = find_path(self.graph, self.addr, x).nodes[1]

        graph_dict = self.graph.get_data()

        for x in graph_dict.keys():

            try:
                self.forwarding_table[x] = find_path(self.graph, self.addr, x).nodes[1]

            except:

                try:
                    self.forwarding_table[x] = find_path(self.graph, self.addr, x).nodes[0]
                except:
                    continue


    def update_graph(self):

        # makes a new graph from new link states or modified link states
        newGraph = Graph(undirected=True)

        for i in self.my_link_state.keys():

            newGraph.add_edge(self.addr, i, self.my_link_state[i][1])

        # visit every nodes' link state and then add every node and it's nbrs as edge
        for x in self.other_link_states.keys():

            for y in self.other_link_states[x].keys():

                newGraph.add_edge(x, y, self.other_link_states[x][y][1])

        self.graph = newGraph


    def broadcast_handle_packet(self, node, packet_to_send):

        for x in self.replica.keys():

            if x == node:
                continue

            # don't send packets to nbrs which are mutual between me and the nbr which sent the link state
            elif x in self.other_link_states[node].keys():
                continue

            else:
                self.send(self.replica[x], packet_to_send)